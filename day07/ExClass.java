package day07;

public class ExClass {
/*
 *  1. 클래스
 *     클래스는 하나의 프로그램이다.
 *     구체적으로 설명하면, 한 프로그램의 설계도라고 할 수 있다.
 *     객체지향 프로그래밍(3세대 언어)은 하나의 커다란 프로그램이 작은 프로그램들을 활용하여 필요한 코드의 양을 줄이는 것이 목표이다.
 *
 *  2. 객체
 *     객체란 클래스 변수를 의미한다.
 *     즉 객체지향 프로그래밍이란, 클래스 변수를 사용하여 그 변수가 생성하는 내부 메시지를 활용해 필요한 프로그램을 만드는 것이다.
 *     클래스라는 것 자체가 한가지 책임에 따라 거기에 알맞는 정보를 넣는 칸과 기능들이 구현되어 있기 때문에
 *     우리가 필요한 클래스 변수, 즉 객체를 만들어 프로그램에서 사용하게 되는 것이다.
 *     
 *  3. 클래스의 구성요소
 *     클래스는 필드와 메소드로 이루어져 있다.
 *     - 필드: 해당 클래스의 객체가 가질 수 있는 데이터를 규정 (=구조체)
 *     - 메소드: 해당 클래스의 객체가 공통적으로 가지고 있는 기능
 *     즉 클래스는 정보를 담을 공간과 기능이 적혀져 있다.
 *     그리고 해당 클래스가 어떤 정보를 담을지는 우리가 객체를 만들면서 설정하게 된다.
 *     만약 똑같은 클래스의 객체라면, 기능은 모두 동일하다!
 *     그러나, 해당 객체의 필드 값이 달라질 수는 있으며 이에 따라 같은 객체와 다른 객체 간의 구분이 가능하다.
 *     
 *  4. 필드
 *     필드란 해당 객체가 내부적으로 가지고 있는 데이터를 할당할 공간을 의미한다.
 *     변수처럼 ※ 데이터타입 필드이름 ; ※ 으로 선언한다.
 *     실제 어떤 데이터가 들어갈지는 해당 객체를 사용할 때 지정해주면 된다.
 *     (ex. Board 클래스의 no, writer 등이 필드가 됨)
 *     
 *  5. 메소드
 *     메소드는 해당 클래스의 모든 객체들이 공통적으로 가지고 있는 기능이다.
 *     필드와는 다르게, 모든 메소드들은 똑같은 로직으로 돌아간다.
 *     예를 들어, 학생의 국영수 점수를 합쳐서 총점을 계산하는 메소드는 A학생이나 B학생이나 모두 동일하다.
 *     
 *  6. 생성자(Constructor)
 *     생성자란 해당 클래스 변수가 초기화될 때 호출되는 메소드이다.
 *     우리가 아무런 생성자를 만들지 않는다면, 자바에서 기본적으로 제공해주는 생성자가 해당 클래스의 필드를 초기화 해준다.
 *     해당 필드의 데이터타입이 참조형이면 null로 초기화, 기본형이면 0으로 초기화 해주는데
 *     만약 사용자가 생성자를 따로 만들어 준다면 기본생성자가 호출되어서 클래스의 필드를 null과 0으로 초기화하고 
 *     사용자의 생성자가 호출되어서 추가적인 작업을 해주게 된다.
 *     
 *     생성자는 메소드이지만, 특수하게 리턴타입이 존재하지 않는 형태이다.
 *     즉, ※ public 클래스이름() {} ※ 으로 선언하게 된다.
 *     또한 다른 메소드의 오버로딩처럼, 파라미터에 따라서 호출되는 생성자도 달라진다.
 *     
 *     사용자가 파라미터가 있는 생성자만 선언 및 구현한다면, 더이상 파라미터 없는 생성자는 사용할 수 없다.
 *     따라서 파라미터가 있는 생성자와 파라미터가 없는 생성자가 모두 필요하다면, 둘다 만들어야 한다!
 *     만약 해당 객체가 외부로부터 어떠한 값을 반드시 받아와야만 한다면, 파라미터가 있는 생성자만 만들어서 외부의 값을 강제할 수도 있다.
 *     
 *  7. 필드와 파라미터의 호출 우선도
 *     필드의 경우, 해당 클래스에서는 어디서든 "접근 가능하다".
 *     하지만 파라미터 혹은 메소드 안의 변수가 필드와 똑같은 이름일 수 있는데, 이때는 무조건 파라미터 혹은 변수가 지칭된다.
 *     
 *     따라서 파라미터 혹은 변수와 똑같은 이름일 경우, 
 *     필드 앞에는 항상 this. 을 붙여서 해당 메소드를 실행하는 "객체의" 라고 의미를 명확하게 해주어야 한다.
 *     
 *  8. null
 *     null이란 참조형 변수들에게서 발생하는 특수한 상태이다.
 *     스택 영역에 해당 변수 공간이 마련되고 주소값이 부여되었지단, 힙 영역 해당 주소에는 아무것도 없는 상태를 의미한다.
 *     null 상태에서는 해당 객체의 필드나 메소드 혹은 배열의 요소에 접근할 수 없다.
 *     만약 null 상태인 참조형 변수의 필드나 메소드, 요소 등에 접근하려고 하면, NullPointerException 에러가 발생한다.
 *     예를 들어
 *     String string = "" ; 과 String string = null ; 은 다른 의미이다.
 *     A. String string = ""; 
 *        이 코드는 String 클래스 객체 string이 있고, 아무런 문자도 안 들어가 있지만,
 *        그 외의 메소드나 공간은 확보가 되어있는 상태이다.
 *        즉, NullPointerException 에러가 발생하지 않는다.
 *     B. String string = null;
 *        이 코드는 String 클래스 객체 string이 선언되었고, 힙 영역의 메모리 주소값까지는 부여가 되었지만,
 *        실제 해당하는 힙 영역의 메모리는 아직 초기화가 안 되어있기 때문에 String 클래스에 관한 내용은 하나도 없는 상태이다.
 *        
 *  9. java.lang.Object
 *     Object 클래스는 자바가 기본적으로 제공하는 클래스인데, 
 *     자바가 기본적으로 제공하든, 누군가가 임의로 만들었든 관계없이 
 *     자바에 존재하는 모든 클래스는 java.lang.Object를 상속받는다.
 *     
 *     상속이란, 부모 클래스의 메소드와 필드를 자식 클래스가 다시 안쓴다고 해도 그대로 받아서 쓸 수 있게 "코드를 물려주는" 것이다.
 *     java.lang.Object는 내부적으로 기본생성자, toString(), equals() 등의 다양한 메소드를 선언 및 구현해서
 *     자식 클래스가 또다시 선언 및 정의를 하지 않아도 쓸 수 있도록 만들어 놓았다.
 *     
 *     하지만 이 Object 클래스가 상속해주는 메소드는 매우 모호하게 구현해 놓았기 때문에,
 *     자식 클래스가 해당 메소드들을 사용하면 부정확한 값을 얻을 가능성이 매우 높다.
 *     따라서 만약 이후에 구현하는 클래스가 toString(), equals() 등의 메소드가 필요하다면
 *     여러분들이 반드시 해당 메소드들을 '재정의' 해주어야 원하는 값을 얻을 수 있을 것이다.
 *     
 *     이렇게 자식 클래스가 부모 클래스의 메소드를 '재정의' 하는 것을 오버라이드(override) 라고 한다.
 *     만약 자식 클래스가 부모 클래스의 메소드를 오버라이드할 때에는
 *     부모 클래스가 해당 메소드를 선언한 방법 그대로 똑같이 적어주어야만 한다.
 *     만약 파라미터의 이름을 제외한 나머지 중 하나라도 틀리면 오버라이드가 되지 않는다.
 *     
 *     A. toString() : 해당 객체의 정보를 String으로 바꿔서 return한다.
 *                     java.lang.Object에서는 public String toString() 으로 선언하였고,
 *                     그 내용은 해당 객체의 정보 중 "패키지.클래스이름@메모리주소" 가 출력되도록 구현해 놓았다.
 *                     만약 우리가 해당 클래스의 정보 중 위의 정보가 아닌, 필드의 값과 관련한 정보를 String으로 출력해야 한다면
 *                     당연히 toString() 메소드를 오버라이드 해야한다.
 *     
 *     B. equals() : 두 객체의 주소값이 아닌, 필드에 저장된 값을 기준으로 해서 두 객체가 같은지 비교한다.
 *                   다만, java.lang.Object의 equals() 메소드는
 *                              return a == b;
 *                   즉 주소값 비교의 결과값을 return하도록 구현되어 있다.
 *                   만약 두 객체의 비교를 해야할 일이 있다면(= 데이터담당 클래스인 경우),
 *                   반드시 equals를 오버라이드 해야한다.
 *                   java.lang.Object의 equals 메소드는 다음과 같이 되어있다.
 *                   
 *                   public boolean equals(Object o){
 *                          return this == o ;
 *                   }
 *        
 *  10. 클래스의 캡슐화와 getter/setter
 *      캡슐화란 클래스의 모든 필드, 그리고 외부가 꼭 알아야 하는 몇몇 메소드를 제외하고 모두가 private 접근제한자를 적용시켜
 *      외부에서는 이 클래스 객체안의 내용을 알 수 없게 만드는 데이터 은닉화의 방법이다.
 *      데이터 은닉화를 하는 이유는 외부가 이 클래스 객체의 필드에 직접 접근해서 값을 저장하거나 불러오게 할 수 없고
 *      반드시 메소드를 이용해서 간접적으로 접근하게 만들기 위함이다.
 *      private으로 설정된 필드에 값을 저장할 때에는 setter라는 메소드를 이용하고
 *      필드에 저장된 값을 호출할 때에는 getter라는 메소드를 이용한다.
 *      
 *      setter 메소드 양식 : ※ public void set필드이름(필드타입 필드이름){
 *                              this.필드이름 = 필드이름 ;          } ※
 *  
 *      getter 메소드 양식 : ※ public 필드타입 get필드이름(){
 *                              return 필드이름 ;      }※
 *  
 *  11. 
 *  12. 
 *  13. 
 *  
 */
}
