package day02;
// 비트연산자
// 비트연산자는 정수를 비트로 변환해서 해당 자리에 대한 연산을 한다.
// & | ^ ~ << >> >>> 등

// &   : 2개의 정수를 이진법으로 변환하고 같은 자리가 1일때만 1이 나오게 된다.
// |   : 2개의 정수를 이진법으로 변환하고 같은 자리가 한개라도 1이면 1이 나오게 된다.
// ^   : 2개의 정수를 이진법으로 변환하고 같은 자리가 다를때만 1이 나오게 된다.
// ~   : 1개의 정수를 이진법으로 변환하고 1은 0으로 0은 1로 변환한다.
// >>  : 지정된 숫자만큼 왼쪽으로 비트를 이동한다.
// <<  : 지정된 숫자만큼 오른쪽으로 비트를 이동하되 부호는 유지한다.
// >>> : 지정된 숫자만큼 오른쪽으로 비트를 이동하되 무조건 +가 되도록 한다. 

public class Ex03Operator05 {
    public static void main(String[] args) {
        byte a = 25 ;
        // 25 = 0001 1001
        byte b = 14 ;
        // 14 = 0000 1110

        // 1. & 연산:
        //   0001 1001
        // & 0000 1110
        // -----------
        //   0000 1000 ----> 8
        System.out.println("a & b: " + ((byte)a & b));

        // 2. | 연산:
        //   0001 1001
        // | 0000 1110
        // ------------
        //   0001 1111 ----> 31
        System.out.println("a | b: " + ((byte)a | b));

        // 3. ^ 연산:
        //   0001 1001
        // ^ 0000 1110
        // ------------
        //   0001 0111 ----> 23
        System.out.println("a ^ b: " + ((byte)a ^ b));

        // 4. ~ 연산:
        // ~ 0001 1001
        // ------------
        //   1110 0110   ----> -128 + 64 + 32 + 4 + 2 = -26  
        System.out.println("~ a: " + ((byte)~ a));

        // 5. << 연산:
        // 왼쪽 쉬프트 연산의 경우, 연산자 오른쪽에 있는 자릿수만큼 오른쪽에 0을 붙여주고
        // 왼쪽 자릿수는 연산자 오른쪽 숫자만큼 날려준다.
        // 0001 1001 << 3
        // 0001 1001 000 ==> 11비트 (바이트는 8비트이므로 왼쪽 3개를 날려준다.)
        // 1 1001 000
        // 1100 1000 ===> 8비트
        System.out.println("a << 3: " + ((byte)(a << 3)));

        // 6. >> 연산:
        // 오른쪽 쉬프트 연산의 경우, 연산자 오른쪽에 있는 자릿수만큼 왼쪽에 1이나 0을 붙여주고
        // 오른쪽 자릿수는 연산자 오른쪽 숫자만큼 날려준다.
        // 0001 1001 >> 4
        // 0000 0001 1001 ===> 맨 앞자리가 0이면 +, 1이면 -이므로 0인경우 0000을 붙여주고 1인경우 1111 붙여준다
        // 0000 0001 ----> 1
        System.out.println("a >> 4: " + ((byte)(a >> 4)));

        a = -120 ;

        // 1000 1000 >> 3
        // 111 1000 1000
        // 111 1000 1
        // 1111 0001 ---> -128 + 1 + 16 + 32 + 64 = -15
        System.out.println("a >> 3: " + ((byte)(a >> 3)));
        
        // 7. >>> 연산:
        // 연산자 뒤에 붙은 숫자만큼 앞에 0을 붙이고, 오른쪽 자리는 뒤에 붙은 숫자만큼 날려준다.
        // 1000 1000 >>> 3
        // 000 1000 1000
        // 000 1000 1
        // 0001 0001 ----> 17 (바이트 기준)
        System.out.println("a >>> 3: " + (byte)(a >>> 3));
        // 위의 결과는, 우리가 예상하기로는 17이 나와야 하지만, -15가 나온다.
        // 왜냐하면 프로그램이 숫자를 int로 바꾼 후에 연산하고 그 결과값을 다시 byte로 바꾸기 때문이다.
        // 즉, 1000 1000 앞에 0을 3개 붙이는게 아니라
        // 1111 1111 1111 1111 1111 1111 1000 1000 앞에 0을 3개 붙이게 된다.
        // 이렇게 되면
        // 0001 1111 1111 1111 1111 1111 1111 0001 이 되고
        // 맨 뒤의 8비트만 바이트로 변환하면 -15가 된다.
        
        // 하지만 자바에서는 비트연산을 잘 안쓴다.
        // 왜냐하면 비트연산이 필요한 곳은 주로 속도가 중요한 분야인 네트워크나 이미지처리 쪽이기 때문
    }
}
