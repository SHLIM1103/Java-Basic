package day04;

public class Ex07Method {
    /*
     *  메소드(Method) : 자바에서 해당 클래스가 가지고 있는 기능
     *                 어떤 특정한 작업을 반복적으로 다른 데서도 하게 되면, 그 코드를 처음부터 끝까지 다시 쓰는 것은 비효율적이다.
     *                 
     *                 그래서 특정 기능을 다시 사용해야 한다면(= 코드를 그래도 다시 사용해야 한다면),
     *                 기능으로 분리하여 메소드로 만들면 이후에 그 메소드를 호출만 해도 
     *                 해당 코드들이 불러와지기 때문에 다시 안써도 돼서 효율적!
     *                 
     *                 메소드는 선언과 구현으로 이루어져 있다.
     *  
     *  선언 : 해당 메소드의 "이름", 실행할 때 필요로 하는 "외부의 값", 이 메소드가 종료되면서 호출됐던 곳으로 보낼 "데이터타입을" 적어줌
     *  
     *  구현 : 해당 메소드의 기능을 우리가 직접 코드로 적어줌
     *  
     *  메소드의 선언과 구현 : ※ 리턴타입 메소드이름(파라미터) {
     *                        메소드의 기능 구현
     *                      }                       ※
     *  
     *  리턴타입 : 해당 메소드가 종료되면서 이 메소드를 호출한 곳으로 보내줄 값의 데이터타입
     *          만약 아무런 데이터도 보내주지 않을 경우, 리턴타입은 void
     *          그 외의 경우에는 기능 구현 안에 반드시 return 이라는 명령어를 통해서
     *          해당 데이터타입과 일치하는 데이터타입을 가진 무언가를 "돌려 보내야" 한다.
     *          return 위치와 상관없이, 메소드에서 코드를 실행하다가 return을 만나는 순간 해당 메소드는 종료된다.
     *          
     *  메소드 이름 : 소문자로 시작하는 동사. 낙타등 표기법을 따른다.
     *  
     *  파라미터 : 이 메소드를 실행하는데 필요로 하는 외부의 값
     *          만약 해당 메소드를 실행하는데 필요로 하는 외부의 값이 여러 개면 여러 개의 파라미터가 들어간다.
     *          파라미터는 우리가 변수를 "선언"하듯, ※ 데이터타입 이름 ※ 으로 하나씩 적어주면 된다.
     *          
     *          파라미터는 해당 메소드 내부에서는 변수처럼 취급되므로 "매개변수" 라고도 부른다.
     *          
     *          파라미터는 해당 메소드 전체가 유효범위이다.
     *          
     *          외부에서 해당 메소드를 호출할 때에 값을 넘겨주어야 하는데, 이때는 파라미터와 이름이 일치할 필요는 없으나
     *          해당 파라미터의 데이터타입과 순서가 일치해야 한다.
     *  
     *  메소드 오버로딩(overloading) : 이름은 같지만 파라미터가 달라져서 같은 목적을 가진 여러 메소드를 한 이름으로 묶는 것
     *                            ex) System.out.println() 은 총 9가지 파라미터에 대해서 오버로딩이 되어있다.
     *                            
     *                            예를들어 우리가 만든 Ex08Calculator 클래스의 경우,
     *                            add,subtract, multiply, divide 메소드들이 int 파라미터 2개에 대한 선언과 구현만 되어있다.
     *                            이 경우 add(1, 3.2) 혹은 add(3.0, 1.4) 와 같이 실수가 파라미터로 포함되는 경우에는 에러가 난다.
     *                            (우리가 해당 메소드들에 대해 "정수 데이터타입을 가진 값 2개"에 대해서만 선언과 구현을 했기 때문)
     *                            실수가 하나라도 들어오는 순간 해당 파라미터를 가진 메소드는 존재하지 않기 때문에 에러가 난다.
     *                            
     *                            따라서 숫자 2개를 더한다, 즉 add 메소드를 여러 개 만들되, 호출할 때 구분이 가능하도록 파라미터가 달라져야 한다.
     *                            그렇다면 파라미터가 달라져야 한다는 것은 무엇일까?
     *                            
     *                            Q) 다음중 파라미터가 다른 메소드 하나는?
     *                            1. void printInfo(String name)
     *                            2. void printInfo(String school)
     *                            3. void printInfo(String RRN)
     *                            4. void printInfo(int age) --> 정답
     *                            (메소드를 호출할 때 중요한 것은 파라미터의 이름이 아니라 파라미터의 데이터타입 순서이기 때문)
     *                            
     *                            Q) printInfo("서울대") 라고 하면 1,2,3번 중 어떤것이 호출되어야 하는가?
     *                            정답은 컴퓨터가 정할 수 없다가 된다. 왜냐하면 1,2,3번 모두다 파라미터로 "스트링"이기만 하면 되기 때문에
     *                            컴퓨터는 "서울대"가 사람 이름인지, 학교이름인지, 주민번호인지 판단하지 않고 오로지 "데이터타입"만 생각한다.
     *                            
     *                            따라서 파라미터가 다르다는 것은 해당 메소드 파라미터 안의 데이터타입의 순서가 다르다는 뜻이 된다.
     *                            즉 파라미터가 같은지 여부가 궁금하면, 이름은 무시하고 파라미터의 데이터타입만 확인하면 알 수 있다.
     *  
     *  접근제한자(Access Modifier) : 해당 메소드 혹은 필드가 외부 클래스가 사용 가능한지를 지정하는 키워드
     *                            키워드: public, protected, default, private 등
     *  
     *       <접근제한자 사용가능 범위>
     *       public    : 해당 메소드 혹은 필드를 어디서든 접근 가능 (외부패키지든 외부클래스든 가능)
     *       protected : 해당 메소드 혹은 필드는 같은 패키지의 다른 클래스들은 자유롭게 접근 가능하지만,
     *                   다른 패키지일 경우에는 해당 클래스를 상속받는 다른 클래스만 접근 가능
     *       default   : 해당 메소드 혹은 필드는 같은 패키지의 다른 클래스들은 자유롭게 접근 가능하지만,
     *                   다른 패키지일 경우에는 모든 접근이 불가능
     *                   default는 switch에서도 사용되기 때문에, 아무런 접근제한자도 안 적어주면 기본적으로 default 접근제한자로 적용된다.
     *                   또한, 같은 패키지에서만 접근 가능하기 때문에 "package 접근제한자" 라고도 부른다.
     *       private   : 해당 메소드 혹은 필드는 모든 외부 클래스가 접근이 불가능하며 오직 해당 클래스 내부에서만 호출 가능
     *                   예전에는 정말정말 클래스 내부에서만 숨겨야하는 내용만 private으로 했지만,
     *                   이제는 외부가 정말정말정말 필요한 내용만 public으로 해두고, 나머지는 모두 다 private으로 하는 것이 정석이다.
     *  
     */
}
